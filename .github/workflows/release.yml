name: Release Package

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Test release version (e.g., 25.11 or 25.11.1-rc)'
        required: true
        type: string
  push:
    tags:
      - 'v*'
    branches:
      - master

permissions:
  contents: write  # Required for creating releases and uploading assets

jobs:
  # Job 0: Validate and determine release type
  validate-and-setup:
    name: Validate and Setup Release
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      is_official_release: ${{ steps.validate.outputs.is_official_release }}
      version: ${{ steps.validate.outputs.version }}
      version_tag: ${{ steps.validate.outputs.version_tag }}
      create_github_release: ${{ steps.validate.outputs.create_github_release }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to check branch
      
      - name: Validate release and extract version
        id: validate
        run: |
          set -e
          
          # Extract version from ege.h
          EGE_VERSION_MAJOR=$(grep -oP '#define\s+EGE_VERSION_MAJOR\s+\K\d+' include/ege.h)
          EGE_VERSION_MINOR=$(grep -oP '#define\s+EGE_VERSION_MINOR\s+\K\d+' include/ege.h)
          EGE_VERSION_PATCH=$(grep -oP '#define\s+EGE_VERSION_PATCH\s+\K\d+' include/ege.h)
          HEADER_VERSION="${EGE_VERSION_MAJOR}.${EGE_VERSION_MINOR}.${EGE_VERSION_PATCH}"
          
          echo "Header version: $HEADER_VERSION"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - test release
            VERSION="${{ inputs.version }}"
            echo "Manual test release triggered with version: $VERSION"
            echo "is_official_release=false" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "version_tag=test-$VERSION" >> $GITHUB_OUTPUT
            echo "create_github_release=false" >> $GITHUB_OUTPUT
            
          elif [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.ref_name }}" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Tag push - official release
            TAG_NAME="${{ github.ref_name }}"
            echo "Tag push detected: $TAG_NAME"
            
            # Validate tag format: v(\d+)\.(\d+)(\.(\d+))?(-\w+)?
            if ! [[ "$TAG_NAME" =~ ^v([0-9]+)\.([0-9]+)(\.([0-9]+))?(-[a-zA-Z0-9_]+)?$ ]]; then
              echo "Error: Tag '$TAG_NAME' does not match required format: v{major}.{minor}[.{patch}][-suffix]"
              echo "Examples: v25.11, v25.11.0, v25.11-rc, v25.11.1-beta"
              exit 1
            fi
            
            # Extract version components from tag
            TAG_MAJOR="${BASH_REMATCH[1]}"
            TAG_MINOR="${BASH_REMATCH[2]}"
            TAG_PATCH="${BASH_REMATCH[4]}"
            TAG_SUFFIX="${BASH_REMATCH[5]}"
            
            # Default patch to 0 if not specified
            if [ -z "$TAG_PATCH" ]; then
              TAG_PATCH="0"
            fi
            
            TAG_VERSION="${TAG_MAJOR}.${TAG_MINOR}.${TAG_PATCH}"
            echo "Parsed tag version: $TAG_VERSION (suffix: ${TAG_SUFFIX:-none})"
            
            # Validate version matches header
            if [ "$TAG_VERSION" != "$HEADER_VERSION" ]; then
              echo "Error: Tag version ($TAG_VERSION) does not match EGE_VERSION in ege.h ($HEADER_VERSION)"
              echo "Please update include/ege.h to match the tag version or create a matching tag."
              exit 1
            fi
            
            # Check if tag is on master branch
            if ! git branch --contains "$TAG_NAME" | grep -q "master"; then
              echo "Error: Tag '$TAG_NAME' is not on the master branch"
              echo "Please ensure the tag is created from master branch."
              exit 1
            fi
            
            echo "✓ Tag validation passed"
            echo "is_official_release=true" >> $GITHUB_OUTPUT
            
            # Use version without 'v' prefix for package name
            VERSION="${TAG_MAJOR}.${TAG_MINOR}"
            if [ "$TAG_PATCH" != "0" ]; then
              VERSION="${VERSION}.${TAG_PATCH}"
            fi
            if [ -n "$TAG_SUFFIX" ]; then
              VERSION="${VERSION}${TAG_SUFFIX}"
            fi
            
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "version_tag=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "create_github_release=true" >> $GITHUB_OUTPUT
            
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/master" ]; then
            # Push to master - test release with header version
            VERSION="${EGE_VERSION_MAJOR}.${EGE_VERSION_MINOR}"
            if [ "$EGE_VERSION_PATCH" != "0" ]; then
              VERSION="${VERSION}.${EGE_VERSION_PATCH}"
            fi
            COMMIT_SHA="${{ github.sha }}"
            COMMIT_SHORT=$(echo "$COMMIT_SHA" | cut -c1-7)
            VERSION="${VERSION}-dev-${COMMIT_SHORT}"
            
            echo "Master branch push detected"
            echo "Creating test release with version: $VERSION"
            echo "is_official_release=false" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "version_tag=dev-${COMMIT_SHORT}" >> $GITHUB_OUTPUT
            echo "create_github_release=false" >> $GITHUB_OUTPUT
            
          else
            echo "Error: Unexpected trigger condition"
            exit 1
          fi
          
          echo "Final version: $(cat $GITHUB_OUTPUT | grep '^version=' | cut -d= -f2)"
  
  # Job 1: Build MSVC libraries
  build-msvc-libraries:
    name: Build MSVC Libraries (${{ matrix.name }})
    needs: validate-and-setup
    permissions:
      contents: read
    strategy:
      matrix:
        include:
          - name: VS2022
            os: windows-latest
            toolset: v143
            lib_subdir: vs2022/x64
          
          - name: VS2019
            os: windows-2019  # Using windows-2019 for consistency with existing CI
            toolset: v142
            lib_subdir: vs2019/x64
          
          - name: VS2017
            os: windows-2019  # VS2017 toolset requires windows-2019 runner
            toolset: v141
            lib_subdir: vs2017/x64
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Setup MSVC
        uses: microsoft/setup-msbuild@v2
      
      - name: Build ${{ matrix.name }}
        run: |
          mkdir build-release
          cd build-release
          cmake .. -T ${{ matrix.toolset }} -DEGE_BUILD_DEMO=ON
          cmake --build . --config Release --parallel
      
      - name: Collect artifacts
        shell: powershell
        run: |
          $libDir = "${{ matrix.lib_subdir }}" -replace '/', '\'
          New-Item -ItemType Directory -Force -Path "artifacts\$libDir"
          Get-ChildItem -Path "build-release" -Recurse -Filter "*.lib" | Copy-Item -Destination "artifacts\$libDir\"
          Write-Host "Collected libraries:"
          Get-ChildItem "artifacts\$libDir\"
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: libs-${{ matrix.name }}
          path: artifacts/${{ matrix.lib_subdir }}/
          retention-days: 7
  
  # Job 2: Build MinGW libraries on Windows
  build-mingw-windows-libraries:
    name: Build MinGW Windows (${{ matrix.name }})
    needs: validate-and-setup
    permissions:
      contents: read
    strategy:
      matrix:
        include:
          - name: MSYS2-Latest
            lib_dir: mingw64
            use_msys2: true
          
          - name: CodeBlocks-GCC14
            lib_dir: codeblocks
            use_msys2: false
            # WinLibs GCC 14.2.0 - matches Code::Blocks 25.03 bundled compiler
            # URL from: https://github.com/brechtsanders/winlibs_mingw/releases
            gcc_url: "https://github.com/brechtsanders/winlibs_mingw/releases/download/14.2.0posix-19.1.1-12.0.0-msvcrt-r2/winlibs-x86_64-posix-seh-gcc-14.2.0-mingw-w64msvcrt-12.0.0-r2.zip"
          
          - name: CLion-GCC13
            lib_dir: redpanda
            use_msys2: false
            # WinLibs GCC 13.1.0 - matches CLion bundled compiler
            # URL from: https://github.com/brechtsanders/winlibs_mingw/releases
            gcc_url: "https://github.com/brechtsanders/winlibs_mingw/releases/download/13.1.0-16.0.5-11.0.0-msvcrt-r5/winlibs-x86_64-posix-seh-gcc-13.1.0-mingw-w64msvcrt-11.0.0-r5.zip"
    
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Setup MSYS2 MinGW
        if: matrix.use_msys2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-make
            mingw-w64-x86_64-ninja
            make
            git
      
      - name: Build with MSYS2
        if: matrix.use_msys2
        shell: msys2 {0}
        run: |
          rm -rf build-release
          mkdir -p build-release
          cd build-release
          
          cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release -DEGE_BUILD_DEMO=ON
          cmake --build . --parallel $(nproc)
          
          mkdir -p ../artifacts/${{ matrix.lib_dir }}
          find . -name "*.a" -exec cp {} ../artifacts/${{ matrix.lib_dir }}/ \;
          
          echo "Collected libraries:"
          ls -la ../artifacts/${{ matrix.lib_dir }}/
      
      - name: Download and Setup WinLibs GCC
        if: ${{ !matrix.use_msys2 }}
        shell: powershell
        run: |
          $url = "${{ matrix.gcc_url }}"
          $output = "mingw64.zip"
          Write-Host "Downloading ${{ matrix.name }}..."
          Invoke-WebRequest -Uri $url -OutFile $output -UseBasicParsing
          Write-Host "Extracting..."
          Expand-Archive -Path $output -DestinationPath "C:\mingw-custom" -Force
          Remove-Item $output
      
      - name: Build with WinLibs
        if: ${{ !matrix.use_msys2 }}
        shell: cmd
        run: |
          set PATH=C:\mingw-custom\mingw64\bin;%PATH%
          
          mkdir build-release
          cd build-release
          
          cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release -DEGE_BUILD_DEMO=ON
          cmake --build . --parallel
      
      - name: Collect WinLibs artifacts
        if: ${{ !matrix.use_msys2 }}
        shell: powershell
        run: |
          New-Item -ItemType Directory -Force -Path "artifacts/${{ matrix.lib_dir }}"
          Get-ChildItem -Path "build-release" -Recurse -Filter "*.a" | Copy-Item -Destination "artifacts/${{ matrix.lib_dir }}/"
          Write-Host "Collected libraries:"
          Get-ChildItem "artifacts/${{ matrix.lib_dir }}/"
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: libs-${{ matrix.name }}
          path: artifacts/${{ matrix.lib_dir }}/
          retention-days: 7
  
  # Job 3: Build cross-compile libraries
  build-cross-libraries:
    name: Build Cross-Compile (${{ matrix.name }})
    needs: validate-and-setup
    permissions:
      contents: read
    strategy:
      matrix:
        include:
          - name: Ubuntu-MinGW
            os: ubuntu-latest
            lib_dir: mingw-w64-debian
          
          - name: macOS-MinGW
            os: macos-latest
            lib_dir: macOS
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Install MinGW-w64 (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y mingw-w64 mingw-w64-tools gcc-mingw-w64-x86-64 g++-mingw-w64-x86-64 cmake make git
      
      - name: Install MinGW-w64 (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew update
          brew install mingw-w64 cmake
      
      - name: Build
        run: |
          rm -rf build-release
          mkdir -p build-release
          cd build-release
          
          cmake .. -DCMAKE_BUILD_TYPE=Release -DEGE_BUILD_DEMO=ON
          cmake --build . --parallel
          
          mkdir -p ../artifacts/${{ matrix.lib_dir }}
          find . -name "*.a" -exec cp {} ../artifacts/${{ matrix.lib_dir }}/ \;
          
          echo "Collected libraries:"
          ls -la ../artifacts/${{ matrix.lib_dir }}/
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: libs-${{ matrix.name }}
          path: artifacts/${{ matrix.lib_dir }}/
          retention-days: 7
  
  # Job 4: Create release package
  create-release-package:
    name: Create Release Package
    needs: [validate-and-setup, build-msvc-libraries, build-mingw-windows-libraries, build-cross-libraries]
    permissions:
      contents: write  # Required for creating releases and uploading assets
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Use validated version
        id: version
        run: |
          VERSION="${{ needs.validate-and-setup.outputs.version }}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION"
          echo "Is official release: ${{ needs.validate-and-setup.outputs.is_official_release }}"
          echo "Create GitHub Release: ${{ needs.validate-and-setup.outputs.create_github_release }}"
      
      - name: Download all library artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: libs-*
          path: artifacts/
      
      - name: Install packaging tools
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full tree rsync
      
      - name: Create release package structure
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          RELEASE_DIR="ege-${VERSION}"
          echo "Creating release directory: $RELEASE_DIR"
          
          # Create base directory structure
          mkdir -p "$RELEASE_DIR"/{demo,doc,include,lib}
          
          # Copy demo files (exclude CMake and build-related files)
          echo "Copying demo files..."
          rsync -av --exclude='CMakeLists.txt' \
                    --exclude='ege_release.cmake' \
                    --exclude='compile-tests' \
                    demo/ "$RELEASE_DIR/demo/"
          
          # Copy include directory
          echo "Copying include directory..."
          cp -r include "$RELEASE_DIR/"
          
          # Copy doc directory
          echo "Copying doc directory..."
          if [ -d "doc" ]; then
            cp -r doc "$RELEASE_DIR/"
          fi
          
          # Copy man directory
          echo "Copying man directory..."
          if [ -d "man" ]; then
            cp -r man "$RELEASE_DIR/"
          fi
          
          # Copy release CMakeLists.txt
          echo "Copying CMakeLists.txt..."
          cp .github/release-assets/CMakeLists.txt "$RELEASE_DIR/"
          
          # Copy logo
          if [ -f "egelogo.jpg" ]; then
            cp egelogo.jpg "$RELEASE_DIR/"
          fi
          
          # Copy README as 说明.txt
          if [ -f "README.md" ]; then
            cp README.md "$RELEASE_DIR/说明.txt"
          fi
          
          # Organize library artifacts
          echo "Organizing library artifacts..."
          
          # List downloaded artifacts
          echo "Downloaded artifacts:"
          find artifacts/ -type f
          
          # MSVC libraries (VS2022, VS2019, VS2017)
          # Artifacts are named libs-VS2022, libs-VS2019, libs-VS2017
          # Each contains the lib files in a vs*/x64 subdirectory structure
          for vsname in VS2022 VS2019 VS2017; do
            vsdir=$(echo "$vsname" | tr '[:upper:]' '[:lower:]')
            if [ -d "artifacts/libs-${vsname}" ]; then
              mkdir -p "$RELEASE_DIR/lib/${vsdir}/x64"
              lib_count=$(find "artifacts/libs-${vsname}" -name "*.lib" -type f | wc -l)
              if [ "$lib_count" -gt 0 ]; then
                find "artifacts/libs-${vsname}" -name "*.lib" -exec cp {} "$RELEASE_DIR/lib/${vsdir}/x64/" \;
                echo "Copied $lib_count library files for ${vsname}"
              else
                echo "Warning: No .lib files found for ${vsname}"
              fi
            else
              echo "Warning: Artifact directory artifacts/libs-${vsname} not found"
            fi
          done
          
          # MinGW libraries
          # Artifacts: libs-MSYS2-Latest, libs-CodeBlocks-GCC14, libs-CLion-GCC13
          declare -A mingw_mappings=(
            ["MSYS2-Latest"]="mingw64"
            ["CodeBlocks-GCC14"]="codeblocks"
            ["CLion-GCC13"]="redpanda"
            ["Ubuntu-MinGW"]="mingw-w64-debian"
            ["macOS-MinGW"]="macOS"
          )
          
          for artifact_name in "${!mingw_mappings[@]}"; do
            target_dir="${mingw_mappings[$artifact_name]}"
            if [ -d "artifacts/libs-${artifact_name}" ]; then
              mkdir -p "$RELEASE_DIR/lib/${target_dir}"
              lib_count=$(find "artifacts/libs-${artifact_name}" -name "*.a" -type f | wc -l)
              if [ "$lib_count" -gt 0 ]; then
                find "artifacts/libs-${artifact_name}" -name "*.a" -exec cp {} "$RELEASE_DIR/lib/${target_dir}/" \;
                echo "Copied $lib_count library files for ${artifact_name} to lib/${target_dir}"
              else
                echo "Warning: No .a files found for ${artifact_name}"
              fi
            else
              echo "Warning: Artifact directory artifacts/libs-${artifact_name} not found"
            fi
          done
          
          # Show the structure
          echo "Release package structure:"
          tree -L 3 "$RELEASE_DIR" || find "$RELEASE_DIR" -type d | sort
          
          echo "Library files:"
          find "$RELEASE_DIR/lib" -type f
          
          # Create version.txt
          echo "$VERSION" > "$RELEASE_DIR/version.txt"
      
      - name: Create archives
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          RELEASE_DIR="ege-${VERSION}"
          
          echo "Creating 7z archive..."
          7z a -t7z -mx=9 "${RELEASE_DIR}.7z" "$RELEASE_DIR"
          
          echo "Creating zip archive..."
          7z a -tzip -mx=9 "${RELEASE_DIR}.zip" "$RELEASE_DIR"
          
          echo "Archive sizes:"
          ls -lh "${RELEASE_DIR}.7z" "${RELEASE_DIR}.zip"
      
      - name: Upload release package as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ege-release-${{ steps.version.outputs.VERSION }}
          path: |
            ege-*.7z
            ege-*.zip
          retention-days: 90
      
      - name: Create GitHub Release
        if: needs.validate-and-setup.outputs.create_github_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate-and-setup.outputs.version_tag }}
          name: EGE ${{ steps.version.outputs.VERSION }}
          draft: true
          files: |
            ege-*.7z
            ege-*.zip
          body: |
            # EGE ${{ steps.version.outputs.VERSION }} Release
            
            ## 下载说明 / Download Instructions
            
            - **ege-${{ steps.version.outputs.VERSION }}.7z** - 完整发布包 (推荐，体积更小)
            - **ege-${{ steps.version.outputs.VERSION }}.zip** - 完整发布包 (ZIP 格式)
            
            ## 包含内容 / Contents
            
            - **demo/** - 示例程序源代码
            - **doc/** - 文档
            - **include/** - 头文件
            - **lib/** - 静态库文件
              - vs2022/vs2019/vs2017 - Visual Studio 静态库
              - mingw64 - MinGW-w64 (MSYS2) 静态库
              - codeblocks - Code::Blocks 25.03 静态库
              - redpanda - CLion/小熊猫C++ 静态库
              - mingw-w64-debian - Ubuntu 交叉编译静态库
              - macOS - macOS 交叉编译静态库
            - **man/** - API 文档
            - **CMakeLists.txt** - CMake 项目文件
            
            ## 使用方法 / Usage
            
            解压后可直接使用 CMake 构建示例程序：
            
            ```bash
            cd ege-${{ steps.version.outputs.VERSION }}
            mkdir build && cd build
            cmake ..
            cmake --build .
            ```
            
            详细使用说明请查看 [官方文档](https://xege.org) 和包内的 `说明.txt` 文件。
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
